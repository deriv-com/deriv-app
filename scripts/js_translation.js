const color   = require('cli-color');
const fs      = require('fs');
const path    = require('path');
const common  = require('./common');
const GetText = require('./gettext');
const extract = require('./extract_js_texts');

const static_app   = require('./js_texts/static_strings_app');
// const static_app_2 = require('./js_texts/static_strings_app_2'); // TODO: uncomment when decided to push app_2 texts to Crowdin

const all_languages = [...common.languages, 'ach'].map(l => l.toLowerCase());
const map = {
    app: {
        static: static_app,
    },
    // app_2: {
    //     static: static_app_2,
    // },
};

const build = () => {
    generateSources();
    const all_texts = getAllTexts();
    const gettext   = GetText.getInstance();

    all_languages.forEach(lang => {
        gettext.setLang(lang);
        Object.keys(map).forEach(app => { map[app][lang] = {}; });

        all_texts.forEach(text => {
            const key         = text.replace(/[\s.]/g, '_');
            const translation = gettext.gettext(text, '[_1]', '[_2]', '[_3]', '[_4]');

            if (translation !== text) {
                Object.keys(map).forEach(app => {
                    if (map[app].source.has(text)) {
                        map[app][lang][key] = translation;
                    }
                });
            }
        });
    });
};

const generate = () => {
    const target_path = 'src/javascript/_autogenerated/';

    console.log(color.cyan('\nGenerating files:')); // eslint-disable-line no-console
    console.log(color.cyan('  Target: '), color.yellow(target_path)); // eslint-disable-line no-console

    all_languages.forEach(lang => {
        process.stdout.write(color.cyan('    -'));
        process.stdout.write(` ${lang}.js ${'.'.repeat(15 - lang.length)}`);

        Object.keys(map).forEach(app => {
            const js_path = path.join(common.root_path, `${target_path}${app !== 'app' ? `${app}/` : ''}${lang}.js`);
            const content = `const texts_json = {};\ntexts_json['${lang.toUpperCase()}'] = ${JSON.stringify(map[app][lang])};`;
            fs.writeFileSync(js_path, content, 'utf8');
        });

        process.stdout.write(common.messageEnd());
    });
};

// ---------- Helpers ----------
const generateSources = () => {
    Object.keys(map).forEach(app => {
        extract.parse(app);
        const extracted_strings = [...extract.getTexts(app)];

        map[app].source = new Set([
            ...extracted_strings,
            ...map[app].static,
        ]);

        writeExtractedStrings(app, extracted_strings);
    });
};

const getAllTexts = () => [ // returns unique texts of all apps in an array
    ...new Set(
        Object.keys(map).reduce(
            (acc, app) => [...acc, ...map[app].source],
            [],
        )
    ),
];

const writeExtractedStrings = (app_name, extracted_strings) => {
    const file_path = path.resolve(common.root_path, `scripts/js_texts/extracted_strings_${app_name}.js`);
    const comments  = '// This is an auto-generated list of strings used in js code for debugging purpose only\n';
    const contents  = `${comments}module.exports = ${singleQuoteArray(extracted_strings)}`;
    fs.writeFileSync(file_path, contents, 'utf8');
};

// JSON.stringify uses double quotes, so in order to have the same style used in the code we wrap array items in single quote
const singleQuoteArray = (texts_array) => {
    const spaces = ' '.repeat(4);
    return `[\n${spaces}'${texts_array.sort().map(str => str.replace(/'/g, '\\\'')).join(`',\n${spaces}'`)}',\n];\n`;
};

exports.build    = build;
exports.generate = generate;
